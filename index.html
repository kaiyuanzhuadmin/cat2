<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <title>è‡­å®åŠ è½½ä¸­...</title>
  <link rel="icon" type="image/png" sizes="96x96" href="me.png">
  <style>
@keyframes card-entry {
  0% { opacity: 0; transform: scale(0.5) translateY(-50px); }
  70% { opacity: 1; transform: scale(1.05) translateY(10px); }
  100% { opacity: 1; transform: scale(1) translateY(0); }
}

    /* New Chinese-style fonts */
    @font-face {
        font-family: 'HanyiSentyLotus';
        src: url('https://fonts.cdnfonts.com/s/72921/hanyisentyjilian.woff') format('woff');
        font-weight: normal;
        font-style: normal;
    }
    @font-face {
        font-family: 'FangSong';
        src: local('FangSong'), local('æ–¹æ­£ä»¿å®‹ç®€ä½“'), local('FZFSJW');
        font-weight: normal;
        font-style: normal;
    }
    @keyframes pulse-scale {
      0%, 100% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.05); opacity: 1; }
    }
    @keyframes text-progress {
      0% { content: "."; }
      33% { content: ".."; }
      66% { content: "..."; }
      100% { content: "."; }
    }
    @keyframes wave {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      25% { transform: translateY(-10px) rotate(2deg); }
      75% { transform: translateY(5px) rotate(-1deg); }
    }
    @keyframes show-card-property {
      0% { opacity: 0; }
      20% { opacity: 1; }
      80% { opacity: 1; }
      100% { opacity: 0; }
    }
    @keyframes fade-in-out-scale {
      0% { opacity: 0; transform: scale(0.8); }
      50% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.9); }
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0) rotate(0deg); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-3px) rotate(-1deg); }
      20%, 40%, 60%, 80% { transform: translateX(3px) rotate(1deg); }
    }
 #start-screen {
      position: absolute;
      left: 0; right: 0; top: 0; bottom: 0;
      z-index: 88;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding-top: 6vh;
      flex-direction: column;
      font-size: 3.3rem;
      border-radius: 25px;
      text-align: center;
      overflow: hidden; /* ç¡®ä¿èƒŒæ™¯å›¾ä¸ä¼šè¶…å‡ºå®¹å™¨ */
      box-sizing: border-box;
    }
    /* æ·»åŠ èƒŒæ™¯å›¾å®¹å™¨ */
    #start-screen::before {
      content: "";
      position: absolute;
      left: 0; right: 0; top: 0; bottom: 0;
      background-image: url('mao.webp'); /* ä½¿ç”¨ä¸bodyç›¸åŒçš„èƒŒæ™¯å›¾ */
      background-size: cover;
      background-position: center;
      opacity: 0.4; /* è®¾ç½®é€æ˜åº¦40% */
      z-index: -1; /* ç¡®ä¿èƒŒæ™¯åœ¨å†…å®¹åé¢ */
    }
    body {
      margin: 0;
      min-height: 100vh;
      overflow-x: hidden;
      font-family: 'FangSong', 'Segoe UI', 'PingFang SC', 'Helvetica Neue', Arial, 'Microsoft Yahei', sans-serif;
      color: #3e2723;
      position: relative; /* å…³é”®ï¼šä¸ºä¼ªå…ƒç´ æä¾›å®šä½å‚è€ƒ */
    }
    body::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #f7f0e8 url('cat1.webp') no-repeat center center fixed;
  background-size: cover;
  z-index: -2; /* ç½®äºå†…å®¹ä¸‹æ–¹ */
}

body::after {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: white;
  opacity: 0.3; /* 30%é€æ˜åº¦çš„ç™½è‰²è’™ç‰ˆ */
  z-index: -1; /* ç½®äºèƒŒæ™¯å›¾ä¸Šæ–¹ã€å†…å®¹ä¸‹æ–¹ */
}
    #game-container {
      max-width: 650px;
      margin: 30px auto;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 25px;
      box-shadow: 0 5px 25px rgba(100, 60, 40, 0.3);
      padding: 0 0 20px 0;
      position: relative;
      min-height: 880px;
      display: flex;
      flex-direction: column;
      align-items: center;
      border: 3px solid #8B4513;
    }
    @media (max-width: 700px) {
      #game-container { max-width: 100vw; margin: 0; box-shadow: none; border-radius: 0; min-height: 100vh; border: none;}
    }
    #header-bar {
      width: 100%;
      padding: 15px 25px 0 25px;
      box-sizing: border-box;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(to bottom, rgba(255,255,255,0.8), rgba(255,255,255,0));
      border-top-left-radius: 22px;
      border-top-right-radius: 22px;
    }
    #progress-info {
      font-size: 1.55rem;
      font-weight: bold;
      color: #5d4037;
      text-shadow: 0.5px 0.5px 0 rgba(255,255,255,0.7);
    }
    #music-toggle {
      background: none;
      border: none;
      outline: none;
      font-size: 1.8rem;
      cursor: pointer;
      color: #6d4c41;
      transition: transform 0.2s ease-in-out;
    }
    #music-toggle:hover {
      transform: scale(1.1);
    }
    #main-area {
      flex:1;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }
    #card-stack-area {
      margin-top: 20px;
      width: 580px;
      height: 500px;
      position: relative;
      background: rgba(240, 230, 210, 0.6);
      border-radius: 15px;
      box-shadow: inset 0 2px 10px rgba(100, 60, 40, 0.15), 0 5px 15px rgba(100, 60, 40, 0.2);
      overflow: visible;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px dashed #b8860b;
    }
    @media (max-width: 650px) {
      #card-stack-area {
        width: 96vw;
        min-width: 250px;
        height: 420px;
      }
    }
    .card {
      width: 65px;
      height: 85px;
      background: #fffdf7;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1), inset 0 0 0 1px rgba(255,255,255,0.5);
      border: 3px solid #d4a762;
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.6rem;
      cursor: pointer;
      user-select: none;
      transition: transform 0.15s ease-out, box-shadow 0.15s ease-out, opacity 0.3s, border-color 0.15s;
      z-index: 1;
      overflow: hidden;
      color: #5d4037;
      user-select: none; /* Add this line */
      -webkit-user-select: none; /* For WebKit browsers (Chrome, Safari) */
      -moz-user-select: none; /* For Firefox */
      -ms-user-select: none; /* For Internet Explorer/Edge */
    }
    .card-entering {
  animation: card-entry 0.5s ease-out forwards; /* Adjust duration and easing as needed */
  /* Add a delay based on index for a staggered effect */
}
    .hint-animation {
      animation: show-card-property 2s forwards; /* Example duration and fill-mode */
}
    .card.selected {
      border: 3.5px solid #a0522d;
      box-shadow: 0 4px 20px rgba(160, 82, 45, 0.4), 0 0 25px rgba(255,255,0,0.5);
      z-index: 100 !important;
      transform: scale(1.01) rotate(-2deg);
    }
    .card.disabled {
      pointer-events: none;
      position: absolute;
    }
    .card.disabled::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(128, 128, 128, 0.3);
      border-radius: 8px;
      z-index: 2;
      transition: background 0.2s ease;
    }
    .card.disabled {
        opacity: 1;
    }
    .card.disabled > *:not(.disabled::before) {
        opacity: 0.5;
    }
    .card:not(.disabled):not(.matched):hover {
      transform: translateY(-5px) scale(1.05) rotate(2deg);
      box-shadow: 0 8px 20px rgba(0,0,0,0.15), inset 0 0 0 1px rgba(255,255,255,0.5);
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
      z-index: 2;
    }
    .card.matched {
      opacity: 0.05;
      transition: opacity 0.15s;
      pointer-events: none;
    }
    .card .mini {
      font-size: 1.2rem;
      position: absolute;
      bottom: 7px;
      right: 9px;
      opacity: 0.5;
      user-select: none; /* Add this line */
      -webkit-user-select: none; /* For WebKit browsers (Chrome, Safari) */
      -moz-user-select: none; /* For Firefox */
      -ms-user-select: none; /* For Internet Explorer/Edge */
    }
    #temp-area {
      margin: 20px auto 0 auto;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 80px;
      width: 500px;
      border-radius: 12px;
      background: #fffcf0;
      border: 2px dashed #b8860b;
      padding: 8px 0;
      box-sizing: border-box;
      box-shadow: inset 0 1px 5px rgba(0,0,0,0.08);
    }
    .temp-slot {
      width: 63px;
      height: 80px;
      margin: 0 6px;
      background: #fdf5e6;
      border-radius: 9px;
      border: 2px dashed #d4a762;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      color: #92776c;
      box-shadow: inset 0 1px 4px rgba(0,0,0,0.05);
      position: relative;
      overflow: hidden;
    }
    .temp-card {
      width: 100%;
      height: 100%;
      background: #fffdf7;
      border-radius: 9px;
      border: 2.5px solid #a0522d;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.2rem;
      box-shadow: 0 2px 8px rgba(160, 82, 45, 0.3);
      cursor: default;
      position: absolute;
      transition: opacity 0.2s, border-color 0.2s, box-shadow 0.2s;
      box-sizing: border-box;
      color: #5d4037;
    }
    .temp-card.matched {
      opacity: 0.05;
    }
    .flying-card {
      width: 65px;
      height: 85px;
      background: #fffdf7;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1), inset 0 0 0 1px rgba(255,255,255,0.5);
      border: 3px solid #d4a762;
      position: fixed;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.6rem;
      user-select: none;
      z-index: 10000; /* Ensured it's on top */
      transition: top 0.3s ease-in-out, left 0.3s ease-in-out, transform 0.3s ease-in-out;
      overflow: hidden;
      color: #5d4037;
    }
    #tools-bar {
      margin: 20px auto 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 18px;
      width: 500px;
      flex-wrap: wrap;
    }
    #tools-bar button {
      padding: 9px 18px;
      background: #f7e9d7;
      border: 2px solid #b8860b;
      border-radius: 10px;
      font-size: 1.05rem;
      color: #6e352f;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
      outline: none;
      position: relative;
      min-width: 75px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    #tools-bar button:hover {
      background: #e9d9c6;
      transform: translateY(-1px);
    }
    #tools-bar button:disabled {
      background: #f0f0f0;
      color: #b0b0b0;
      border-color: #d0d0d0;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    #restart-btn {
      background: #ffe0b3;
      border-color: #ffcc80;
      color: #96602c;
    }
    #restart-btn:hover {
      background: #ffd599;
    }
    #code-bar {
      margin: 15px auto 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 450px;
    }
    #code-bar input {
      width: 180px;
      padding: 7px 10px;
      border-radius: 8px;
      border: 2px solid #b8860b;
      outline: none;
      font-size: 1.05rem;
      color: #5d4037;
      background: #fffdf7;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    }
    #code-bar input::placeholder {
      color: #a0a0a0;
    }
    #code-bar button {
      padding: 7px 12px;
      font-size: 1.05rem;
      background: #e6f6d3;
      border: 2px solid #a0c388;
      border-radius: 9px;
      cursor: pointer;
      color: #3e5a2b;
      font-weight: bold;
      transition: background 0.15s;
      min-width: 65px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    }
    #code-bar button:hover {
      background: #d2e5bb;
    }
    #message-bar {
      margin: 15px auto 0 auto;
      text-align: center;
      font-size: 1.1rem;
      color: #c0392b;
      min-height: 28px;
      font-weight: bold;
      letter-spacing: 1.2px;
    }
    #start-screen, #level-finish, #game-over {
      position: absolute;
      left: 0; right: 0; top: 0; bottom: 0;
      z-index: 88;
      background: rgba(255,255,255,0.98);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      font-size: 1.1rem;
      border-radius: 25px;
      text-align: center;
    }
    #start-screen h1 {
      font-size: 4rem;
      margin: 0 0 25px 0;
      letter-spacing: 3px;
      text-shadow: 2px 2px 0 #f7e9d7, 4px 4px 0 #b8860b;
      display: inline-block;
    }
    #start-screen h1 span {
      display: inline-block;
      animation: wave 2s infinite ease-in-out;
}
#start-screen h1 span:nth-child(1) { animation-delay: -0.4s; }
#start-screen h1 span:nth-child(2) { animation-delay: -0.2s; }
#start-screen h1 span:nth-child(3) { animation-delay: 0s; }
#start-screen h1 span:nth-child(4) { animation-delay: 0.2s; }
#start-screen h1 span:nth-child(5) { animation-delay: 0.4s; } /* é’ˆå¯¹æœ€åçš„emoji */
    #start-screen .start-btn {
      margin-top: 30px;
      padding: 15px 50px;
      font-size: 1.4rem;
      background: linear-gradient(90deg, #a0c388, #88b368);
      border: none;
      border-radius: 15px;
      color: #3e5a2b;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(160, 195, 136, 0.5);
      animation: pulse-scale 1.5s infinite ease-in-out;
      transition: background 0.2s, transform 0.1s;
    }
    #start-screen .start-btn:hover {
      background: linear-gradient(90deg, #88b368, #a0c388);
      transform: translateY(-2px);
    }
    #start-screen p {
        color: #5d4037;
        line-height: 1.6;
        margin: 0 40px 15px;
        /* MODIFIED: Pushed down from title */
        margin-top: 15vh;
    }
    #start-screen span {
        color: #c0392b;
        font-weight: bold;
    }
    #start-screen small {
        color: #795548;
        font-size: 0.85rem;
        /* MODIFIED: Positioned at the bottom */
        position: absolute;
        bottom: 30px;
        left: 0;
        right: 0;
        text-align: center;
    }
    #level-finish {
      font-size: 1.8rem;
      font-family: 'Segoe UI', 'PingFang SC', 'Helvetica Neue', Arial, 'Microsoft Yahei', sans-serif;
      color: #5d4037;
      background: rgba(255,243,245,0.99);
      border-radius: 25px;
      position: absolute;
      overflow: hidden; /* ç¡®ä¿èƒŒæ™¯å›¾ä¸è¶…å‡ºå®¹å™¨ */
      border: 3px solid #8B4513; /* ä¸æ¸¸æˆå®¹å™¨è¾¹æ¡†ä¸€è‡´ */
      box-shadow: 0 5px 25px rgba(100, 60, 40, 0.3); /* ä¸æ¸¸æˆå®¹å™¨é˜´å½±ä¸€è‡´ */
      /*animation: shake 3s infinite; /* Add these lines */
    }

    #game-over {
      font-size: 1.8rem;
      font-family: 'Segoe UI', 'PingFang SC', 'Helvetica Neue', Arial, 'Microsoft Yahei', sans-serif;
      color: #5d4037;
      background: rgba(255,243,245,0.99);
      border-radius: 25px;
      position: absolute;
      overflow: hidden; /* ç¡®ä¿èƒŒæ™¯å›¾ä¸è¶…å‡ºå®¹å™¨ */
      border: 3px solid #8B4513; /* ä¸æ¸¸æˆå®¹å™¨è¾¹æ¡†ä¸€è‡´ */
      box-shadow: 0 5px 25px rgba(100, 60, 40, 0.3); /* ä¸æ¸¸æˆå®¹å™¨é˜´å½±ä¸€è‡´ */
      animation: wave 2s infinite; /* Add these lines */
    }
    #level-finish::before, #game-over::before {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      background-image: url('mao1.webp'); /* ä½¿ç”¨ä¸å¼€å§‹ç•Œé¢ç›¸åŒçš„èƒŒæ™¯å›¾ */
      background-size: cover;
      background-position: center;
      opacity: 0.4; /* é€æ˜åº¦40% */
      z-index: -1; /* ç¡®ä¿èƒŒæ™¯åœ¨å†…å®¹ä¸‹æ–¹ */
}
    #level-finish button, #game-over button {
      margin-top: 25px;
      padding: 12px 35px;
      font-size: 1.25rem;
      background: #e6f6d3;
      border: 2px solid #a0c388;
      border-radius: 12px;
      color: #3e5a2b;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    #level-finish button:hover, #game-over button:hover {
      background: #d2e5bb;
      transform: translateY(-1px);
    }
    #retry-btn {
      margin-top: 18px;
      padding: 10px 30px;
      font-size: 1.15rem;
      background: #f7e9d7;
      border: 2px solid #d4a762;
      border-radius: 10px;
      color: #6e352f;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
      display: inline-block;
      box-shadow: 0 1px 5px rgba(0,0,0,0.1);
    }
    #retry-btn:hover {
      background: #f0e1d0;
      transform: translateY(-1px);
    }
    #footer {
      margin: 20px auto 0 auto;
      width: 100%;
      text-align: center;
      font-size: 1rem;
      color: #8B4513;
      font-family: 'FangSong', 'Comic Sans MS', cursive;
      letter-spacing: 1.5px;
      text-shadow: 0.5px 0.5px 0 rgba(255,255,255,0.5);
    }
    /* --- Styles for Level 2 on ALL devices to reduce difficulty --- */
    body.level-2-active .card {
      width: 50px;
      height: 65px;
      font-size: 2rem;
      border-width: 2px;
      border-radius: 8px;
    }
    body.level-2-active .flying-card {
      width: 50px;
      height: 65px;
      font-size: 2rem;
      border-width: 2px;
      border-radius: 8px;
    }
    body.level-2-active .temp-slot {
      width: 45px;
      height: 60px;
      margin: 0 4px;
      border-width: 1.5px;
      border-radius: 7px;
    }
    body.level-2-active .temp-card {
      font-size: 1.8rem;
      border-width: 1.5px;
      border-radius: 7px;
    }
    body.level-2-active #temp-area {
      width: 380px;
      min-height: 65px;
      padding: 6px 0;
    }
    body.level-2-active #card-stack-area {
      height: 420px;
    }
    /* --- End new styles --- */
    .hinted-shake {
      animation: shake 0.5s ease-in-out 4; /* Adjust duration and iteration count as needed */
      /* You can also add a subtle visual highlight here if you want it to persist during the shake */
      /* For example: border-color: #e65c4f !important; box-shadow: 0 0 16px #ff8c69 !important; */
    }
    /* --- Custom Confirm Modal Styles --- */
    .modal-overlay {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.6);
        /* ä¿®å¤é—®é¢˜ï¼šå¢åŠ z-indexå€¼ç¡®ä¿æ¨¡æ€æ¡†åœ¨æœ€ä¸Šå±‚ */
        z-index: 2500; /* åŸå€¼ä¸º1000 */
        display: none;
        align-items: center;
        justify-content: center;
    }
    .modal-content {
        background: #fffdf7;
        padding: 30px 40px;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        border: 3px solid #d4a762;
    }
    .modal-content p {
        font-size: 1.2rem;
        color: #5d4037;
        margin: 0 0 25px 0;
        font-weight: bold;
    }
    .modal-content button {
        padding: 9px 25px;
        background: #f7e9d7;
        border: 2px solid #b8860b;
        border-radius: 10px;
        font-size: 1.05rem;
        color: #6e352f;
        font-weight: bold;
        cursor: pointer;
        margin: 0 10px;
        transition: background 0.15s, transform 0.1s;
    }
    .modal-content button:hover {
        transform: translateY(-1px);
    }
    #confirm-yes {
        background: #e6f6d3;
        border-color: #a0c388;
        color: #3e5a2b;
    }
    #confirm-yes:hover {
        background: #d2e5bb;
    }
    #confirm-no:hover {
        background: #e9d9c6;
    }
    /* --- End Modal Styles --- */
   #level-finish-text {
      font-family: 'Microsoft Yahei','Segoe UI', 'PingFang SC', 'Helvetica Neue', Arial, sans-serif;
      color: #3e2723;
      font-size: 1.2em; /* å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´å­—ä½“å¤§å° */
      text-align: center;
      margin-bottom: 20px;
      }
    /* --- Loading Screen Styles --- */
    #loading-screen {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #f7f0e8; /* Game's main background color */
      background-size: cover;
      transition: opacity 0.5s ease-out;
    }
    #loading-screen::before {
      content: '';
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: #f7f0e8 url('mao3.webp') no-repeat center center fixed;
      background-size: cover;
      opacity: 0.6;/*ä¸é€æ˜åº¦60%
      z-index: -1;
    }
    .loading-content {
      position: relative;
      z-index: 1;
      text-align: center;
      width: 80%;
      max-width: 500px;
      /* MODIFIED: Changed to flex layout for vertical spacing */
      display: flex;
      flex-direction: column;
      height: 100%;
      align-items: center;
      justify-content: flex-start;
      padding-top: 6vh;
      box-sizing: border-box;
    }
    .loading-title {
  font-size: 2.8rem;
  margin: 0 0 40px 0;
  font-family: 'FangSong', 'Segoe UI', 'PingFang SC', 'Helvetica Neue', Arial, 'Microsoft Yahei', sans-serif;
  color: #3e2723;
  letter-spacing: 3px;
  text-shadow: 2px 2px 0 #f7e9d7, 4px 4px 0 #b8860b;
  animation: pulse-scale 1.5s infinite ease-in-out;
}
    .loading-title::after {
  content: ".";
  animation: text-progress 2s infinite;
}
    .progress-bar-container {
      width: 100%;
      height: 30px;
      background: rgba(184, 134, 11, 0.2);
      border-radius: 10px;
      border: 2px solid #b8860b;
      overflow: hidden;
      margin-bottom: 15px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
      /* MODIFIED: Pushed down from the title */
      margin-top: 40vh;
      z-index: 4;
    }
    #progress-bar {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #a0c388, #88b368);
      border-radius: 8px;
      transition: width 0.3s ease-out;
    }
    #loading-text {
      font-size: 1.1rem;
      color: #5d4037;
      margin-bottom: 40px;
      min-height: 20px;
      text-align: center;
    }
    .loading-footer {
      font-size: 1rem;
      color: #8B4513;
      font-family: 'FangSong', 'Comic Sans MS', cursive;
      letter-spacing: 1.5px;
      text-shadow: 0.5px 0.5px 0 rgba(255,255,255,0.5);
      /* MODIFIED: Positioned at the bottom */
      position: absolute;
      bottom: 30px;
      left: 0;
      right: 0;
      text-align: center;
    }
    /* --- End Loading Screen Styles --- */

    @media (max-width: 500px) {
      #card-stack-area, #temp-area, #tools-bar, #code-bar { width: 98vw; }
      #tools-bar button {
          min-width: unset;
          width: 30%;
          margin-bottom: 8px;
          padding: 8px 10px;
          font-size: 0.95rem;
      }
      #tools-bar {
          gap: 6px;
      }
      #temp-area {
        width: 98vw;
        margin: 15px auto 0 auto;
      }
      .temp-slot {
        width: 12vw;
        height: 16vw;
        margin: 0 0.8vw;
      }
      .temp-card {
        font-size: 6vw;
      }
      .card {
        width: 15vw;
        height: 20vw;
        font-size: 8vw;
      }
      body.level-2-active .card {
        width: 12vw;
        height: 16vw;
        font-size: 6vw;
      }
      body.level-2-active .temp-slot {
        width: 11vw;
        height: 15vw;
        margin: 0 0.8vw;
      }
      #code-bar input {
        width: 50%;
      }
    }
 </style>
 <link rel="stylesheet" href="font/iconfont.css">
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
<div id="loading-screen">
  <div class="loading-content">
    <h1 class="loading-title">Loading.</h1>
    <div class="progress-bar-container">
      <div id="progress-bar"></div>
    </div>
    <p id="loading-text">æ­£åœ¨åŠ è½½èµ„æº...</p>
    <small class="loading-footer">å–µäº†ä¸ªå’ª &copy; 2025 | Designed by å¼€å…ƒ</small>
  </div>
</div>

<div id="game-container">
  <div id="header-bar">
    <div id="progress-info">å…³å¡: 1 / 2 | å‰©ä½™å¡ç‰Œ: --</div>
    <button id="music-toggle" title="éŸ³ä¹å¼€å…³">ğŸ¼</button>
  </div>
  <div id="main-area">
    <div id="card-stack-area"></div>
    <div id="temp-area">
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
    </div>
    <div id="tools-bar">
      <button id="undo-btn" disabled title="æ’¤é”€(éœ€å…‘æ¢ç )">â†©ï¸ æ’¤é”€ (<span id="undo-count">0</span>)</button>
      <button id="hint-btn" disabled title="æç¤º(éœ€å…‘æ¢ç )">ğŸ’¡ æç¤º (<span id="hint-count">0</span>)</button>
      <button id="shuffle-btn" disabled title="æ´—ç‰Œ(éœ€å…‘æ¢ç )">ğŸ”€ æ´—ç‰Œ (<span id="shuffle-count">0</span>)</button>
      <button id="restart-btn" title="é‡æ–°å¼€å§‹å½“å‰å…³å¡">ğŸ”„ é‡æ–°å¼€å§‹</button>
    </div>
    <div id="code-bar">
      <input type="text" id="code-input" placeholder="å…‘æ¢ç " maxlength="12">
      <button id="code-btn">å…‘æ¢</button>
    </div>
    <div id="message-bar"></div>
  </div>
  <div id="start-screen">
     <h1><span>å–µ</span><span>äº†</span><span>ä¸ª</span><span>å’ª</span><span> ğŸ¾</span></h1>
  <!-- å…¶ä»–å†…å®¹ä¿æŒä¸å˜ -->
    <p>
      <p>
      <button class="start-btn" id="start-btn">å¼€å§‹æ¸¸æˆ</button>
      </p>
      ç‚¹å‡»å¡ç‰Œè¿›è¡Œæ”¶é›†ï¼Œå…¨éƒ¨æ¸…ç©ºè¿‡å…³<br>
      <span style="color:#c0392b;">ç¬¬äºŒå…³éš¾åº¦ç•¥å¾®å‡çº§</span>å¯ä½¿ç”¨å…‘æ¢ç è§£é”é“å…·
    <small>å–µäº†ä¸ªå’ª &copy; 2025 | Designed by å¼€å…ƒ</small>
  </div>
  <div id="level-finish" style="display:none;">
  <div id="player" style="display:none;">
        <div id="player-content1">
            <div class="music-name"></div>
            <div class="artist-name"></div>
            <div class="time">
                <div class="current-time"></div>
                <div class="total-time"></div>
            </div>
            <div id="s-area">
                <div id="ins-time"></div>
                <div id="s-hover"></div>
                <div id="seek-bar"></div>
            </div>
        </div>

        <div id="player-content2">
            <div class="music-imgs">
                <div class="img"></div>
                <div id="buffer-box">ç¼“å†²,ç¨ç­‰â€¦</div>
            </div>
            <div class="player-controls">
                <div class="btn prev iconfont">&#xe603;</div>
                <div class="btn play-pause icon-jiediankaishi iconfont"></div>
                <div class="btn next iconfont">&#xe602;</div>
            </div>
        </div>
    </div>

    <div id="level-finish-text"></div>
    <button id="next-btn">ä¸‹ä¸€å…³</button>
    <button id="retry-btn" style="margin-left:10px;">é‡ç©</button>
    <button id="gobang-btn" style="margin-left:10px; display:none;">äº”å­æ£‹å¯¹å¼ˆ</button>
    <button id="close-game-btn-level" style="margin-left:10px;">å…³é—­æ¸¸æˆ</button> </div>
  </div>
  <div id="game-over" style="display:none;">
    <div id="game-over-text"></div>
    <button id="retry-btn2">é‡è¯•</button>
    <button id="close-game-btn-gameover" style="margin-left:10px;">å…³é—­æ¸¸æˆ</button> </div>
  </div>
  <div id="footer">
      å–µäº†ä¸ªå’ª &copy; 2025 | Designed by å¼€å…ƒ
  </div>
</div>

<div id="confirm-modal" class="modal-overlay">
  <div class="modal-content">
    <p id="confirm-msg">ä½ ç¡®å®šå—ï¼Ÿ</p>
    <div class="modal-buttons">
        <button id="confirm-yes">ç¡®å®š</button>
        <button id="confirm-no">å–æ¶ˆ</button>
    </div>
  </div>
</div>


<audio id="bgm" src="Get.mp3" loop preload="auto"></audio>
<audio id="click-sound" src="kaa.mp3" preload="auto"></audio>
 <script src="js/jquery-3.4.1.min.js"></script>
    <script src="js/index.js"></script>
<script>
const CARD_ICONS = [
  "ğŸˆ", "ğŸ’", "ğŸ§©", "ğŸ‘’", "ğŸµï¸", "ğŸ§¸", "ğŸ¬", "ğŸ”®", "ğŸ¡", "ğŸª™", "ğŸšµâ€â™€ï¸", "ğŸª­",
  "ğŸ–", "ğŸ§¶", "ğŸŒ»", "âœ‚ï¸", "ğŸ¦‹", "ğŸ„"
];
const LEVELS = [
  {num: 1, visible: 18, total: 21, stack: 1, rows: 3, cols: 6, overlap: 30},
  {num: 2, visible: 90, total: 150, stack: 2, rows: 7, cols: 9, overlap: 22}
];
const TEMP_LIMIT = 7;

/*
* MODIFICATION START: Replaced single code with an object for multiple codes.
* You can now add, remove, or change codes and their rewards here.
* The key is the redemption code (in lowercase).
* The value is an object specifying the counts for each tool.
*/
const REDEMPTION_CODES = {
  "kaiyuan": { undo: 20, hint: 20, shuffle: 20 },
  "å…‘æ¢ç ": { undo: 5, hint: 5, shuffle: 5 },
  "princess": { undo: 50, hint: 50, shuffle: 50 },
  "ä¸çŸ¥é“": { undo: 3, hint: 1, shuffle: 1 },
  "å¼€å…ƒ": { undo: 10, hint: 10, shuffle: 10 },
  "é€šå…³": { type: "skip_level" } // Added "é€šå…³" redemption code
};
// MODIFICATION END

const bgm = document.getElementById('bgm');
const confirmModal = document.getElementById('confirm-modal');
const confirmMsg = document.getElementById('confirm-msg');
const confirmYes = document.getElementById('confirm-yes');
const confirmNo = document.getElementById('confirm-no');
const footer = document.getElementById('footer');

let confirmCallback = null;

let game = {
  level: 1,
  cards: [],
  board: [],
  temp: [],
  matched: [],
  usedIcons: [],
  toolUses: {undo: 0, hint: 0, shuffle: 0},
  progress: 0,
  stepStack: [],
  bgmOn: true,
  isNewLevel: false, // Add this flag
  lock: false // This lock prevents multiple clicks causing issues
};

function randArr(arr) {
  return arr.slice().sort(()=>Math.random()-0.5);
}
function shuffle(arr) {
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
  return arr;
}
function deepClone(obj){
  return JSON.parse(JSON.stringify(obj));
}
function randBetween(a,b){ return a + Math.random()*(b-a); }

function playBgm(on) {
  if (!bgm) return;
  if (on) {
    const playPromise = bgm.play();
    if (playPromise !== undefined) {
      playPromise.catch(error => {
        console.error("BGM autoplay was prevented:", error);
        game.bgmOn = false;
        document.getElementById('music-toggle').innerHTML = 'â–¶ï¸';
      });
    }
  } else {
    bgm.pause();
  }
}
let clickSoundPool = [];
const MAX_CLICK_SOUNDS = 10; // å®šä¹‰æœ€å¤šåŒæ—¶æ’­æ”¾çš„ç‚¹å‡»éŸ³æ•ˆæ•°é‡

function createClickSoundInstance() {
    const audio = new Audio('kaa.mp3'); // ä½¿ç”¨ Audio æ„é€ å‡½æ•°åˆ›å»ºæ–°å®ä¾‹
    audio.preload = 'auto';
    audio.volume = 0.4; // é»˜è®¤éŸ³é‡
    return audio;
}

// æå‰åˆ›å»ºä¸€äº›éŸ³é¢‘å®ä¾‹æ”¾å…¥æ± ä¸­
for (let i = 0; i < MAX_CLICK_SOUNDS; i++) {
    clickSoundPool.push(createClickSoundInstance());
}

function playClickSound() {
  if (game.bgmOn) {
    // ä»æ± ä¸­è·å–ä¸€ä¸ªå¯ç”¨çš„éŸ³é¢‘å®ä¾‹
    let soundInstance = clickSoundPool.find(audio => audio.paused || audio.ended);

    if (!soundInstance) {
        // å¦‚æœæ± ä¸­æ²¡æœ‰å¯ç”¨çš„ï¼Œå°±åˆ›å»ºä¸€ä¸ªæ–°çš„ï¼ˆè¿™å¯èƒ½ä¼šå¯¼è‡´çŸ­æ—¶é—´å†…çš„é¢å¤–å†…å­˜ä½¿ç”¨ï¼Œä½†ç¡®ä¿äº†å£°éŸ³æ’­æ”¾ï¼‰
        soundInstance = createClickSoundInstance();
        // å¯é€‰ï¼šå¦‚æœå¸Œæœ›é™åˆ¶å®ä¾‹æ•°é‡ï¼Œå¯ä»¥æ›¿æ¢æ‰æ± ä¸­æœ€è€çš„å®ä¾‹ï¼Œæˆ–è€…ä¸æ·»åŠ åˆ°æ± ä¸­
        // clickSoundPool.shift();
        // clickSoundPool.push(soundInstance);
    }

    soundInstance.currentTime = 0; // ç¡®ä¿æ¯æ¬¡éƒ½ä»å¤´å¼€å§‹æ’­æ”¾
    soundInstance.play().catch(e => console.error("Click sound failed:", e));
  }
}
function showConfirm(msg, callback) {
  confirmMsg.textContent = msg;
  confirmCallback = callback;
  confirmModal.style.display = 'flex';
}

function hideConfirm() {
  confirmModal.style.display = 'none';
  confirmCallback = null;
}

confirmYes.onclick = () => {
  const callback = confirmCallback;
  hideConfirm();
  if (callback) {
    setTimeout(callback, 20);
  }
};

confirmNo.onclick = hideConfirm;

function genLevel(levelIdx){
  const lv = LEVELS[levelIdx-1];

  let allIcons = [];
  const requiredUniqueIcons = Math.ceil(lv.total / 3);
  let availableIcons = randArr(CARD_ICONS);
  availableIcons = availableIcons.slice(0, Math.min(availableIcons.length, requiredUniqueIcons + 2));

  let iconPool = [];
  for (let i = 0; i < requiredUniqueIcons; i++) {
    for (let j = 0; j < 3; j++) {
      iconPool.push(availableIcons[i % availableIcons.length]);
    }
  }
  while (iconPool.length < lv.total) {
      const remaining = lv.total - iconPool.length;
      if (remaining < 3) {
          for (let i = 0; i < remaining; i++) {
              iconPool.push(availableIcons[i % availableIcons.length]);
          }
      } else {
          const iconToAdd = availableIcons[Math.floor(Math.random() * availableIcons.length)];
          iconPool.push(iconToAdd, iconToAdd, iconToAdd);
      }
  }
  shuffle(iconPool);
  allIcons = iconPool;

  let cards = [];
  for(let i = 0; i < lv.total; i++){
    cards.push({
      id: i,
      icon: allIcons[i],
      matched: false
    });
  }

  let board = [];
  const areaW = document.getElementById('card-stack-area').offsetWidth;
  const areaH = document.getElementById('card-stack-area').offsetHeight;

  let cardW = (levelIdx === 2) ? 50 : 65;
  let cardH = (levelIdx === 2) ? 65 : 85;
  let stackDepth = lv.stack;

  const cardsPerStackLayer = Math.ceil(lv.total / stackDepth);

  for (let cardIdx = 0; cardIdx < lv.total; cardIdx++) {
    const s = Math.min(Math.floor(cardIdx / cardsPerStackLayer), stackDepth - 1);

    let x = 0, y = 0;
    let maxAttempts = 50;
    let foundPosition = false;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      let tempX = randBetween(5, areaW - cardW - 5);
      let tempY = randBetween(5, areaH - cardH - 5);

      tempX += (s * 5 * (Math.random() - 0.5));
      tempY += (s * 5 * (Math.random() - 0.5));

      tempX = Math.max(5, Math.min(tempX, areaW - cardW - 5));
      tempY = Math.max(5, Math.min(tempY, areaH - cardH - 5));

      let overlap = false;
      for (const existingCard of board) {
        if (existingCard.stack <= s) {
          const dx = Math.abs(tempX - existingCard.x);
          const dy = Math.abs(tempY - existingCard.y);
          if (dx < cardW * 0.7 && dy < cardH * 0.7) {
            overlap = true;
            break;
          }
        }
      }

      if (!overlap) {
        x = tempX;
        y = tempY;
        foundPosition = true;
        break;
      }
    }

    if (!foundPosition) {
        x = randBetween(5, areaW - cardW - 5);
        y = randBetween(5, areaH - cardH - 5);
    }

    const z = s * 1000 + cardIdx;

    board.push({
      id: cards[cardIdx].id,
      icon: cards[cardIdx].icon,
      x, y, z,
      matched: false,
      covered: false,
      stack: s
    });
  }

  board.sort((a, b) => a.z - b.z);

  return {cards, board, usedIcons: availableIcons.slice(0, Math.ceil(lv.total/3))};
}

function isCardClickable(card, board){
  if(card.matched) return false;

  const activeCards = board.filter(c => !c.matched);

  const cardW = (game.level === 2) ? 50 : 65;
  const cardH = (game.level === 2) ? 65 : 85;
  const overlapThresholdX = cardW * 0.7;
  const overlapThresholdY = cardH * 0.7;

  for (const otherCard of activeCards) {
    if (card.id === otherCard.id) {
      continue;
    }

    if (otherCard.z > card.z) {
      const dx = Math.abs(otherCard.x - card.x);
      const dy = Math.abs(otherCard.y - card.y);

      if (dx < overlapThresholdX && dy < overlapThresholdY) {
        return false;
      }
    }
  }

  return true;
}

function clickCard(id) {
  if (game.lock) return;

  let cardData = game.board.find(c => c.id === id);

  if (!cardData || cardData.matched || !isCardClickable(cardData, game.board)) return;

  let tempCheck = [...game.temp, { icon: cardData.icon, id: cardData.id }];
  let iconCntCheck = {};
  tempCheck.forEach(c => iconCntCheck[c.icon] = (iconCntCheck[c.icon] || 0) + 1);
  let matchedIconCheck = Object.keys(iconCntCheck).find(k => iconCntCheck[k] === 3);

  if (game.temp.length >= TEMP_LIMIT && !matchedIconCheck) {
      gameOver('æš‚å­˜åŒºå·²è¶…é™ï¼Œæ¸¸æˆå¤±è´¥ï¼');
      return;
  }

  saveStep();
  game.lock = true;

  const clickedCardEl = document.querySelector(`#card-stack-area .card[data-id='${id}']`);
  if (!clickedCardEl) {
    game.lock = false;
    return;
  }

  const startRect = clickedCardEl.getBoundingClientRect();

  const flyingCard = document.createElement('div');
  flyingCard.className = 'flying-card';
  flyingCard.innerHTML = cardData.icon;
  document.body.appendChild(flyingCard);

  flyingCard.style.left = `${startRect.left}px`;
  flyingCard.style.top = `${startRect.top}px`;
  flyingCard.style.width = `${startRect.width}px`;
  flyingCard.style.height = `${startRect.height}px`;

  clickedCardEl.style.opacity = '0';
  clickedCardEl.style.pointerEvents = 'none';

  playClickSound();

  const animationDuration = 150;
  const tempAppearanceDelay = 80;

  requestAnimationFrame(() => {
    const tempForPositionCalculation = [...game.temp, { icon: cardData.icon, id: cardData.id }];
    tempForPositionCalculation.sort((a, b) => a.icon.localeCompare(b.icon) || a.id - b.id);
    const endSlotIndex = tempForPositionCalculation.findIndex(c => c.id === id);
    const tempSlots = document.querySelectorAll('#temp-area .temp-slot');

    if (endSlotIndex < 0 || endSlotIndex >= tempSlots.length) {
        console.error("Invalid end slot index calculated for flying card. Aborting animation.");
        document.body.removeChild(flyingCard);
        game.lock = false;
        return;
    }

    const endRect = tempSlots[endSlotIndex].getBoundingClientRect();
    const tempSlotStyle = window.getComputedStyle(tempSlots[endSlotIndex]);
    const flyingCardFinalWidth = parseFloat(tempSlotStyle.width) * 0.9;
    const flyingCardFinalHeight = parseFloat(tempSlotStyle.height) * 0.9;

    const destLeft = endRect.left + (endRect.width - flyingCardFinalWidth) / 2;
    const destTop = endRect.top + (endRect.height - flyingCardFinalHeight) / 2;

    flyingCard.style.left = `${destLeft}px`;
    flyingCard.style.top = `${destTop}px`;
    flyingCard.style.transform = `scale(${flyingCardFinalWidth / parseFloat(startRect.width)})`;
  });

  setTimeout(() => {
    document.body.removeChild(flyingCard);
  }, animationDuration);

  setTimeout(() => {
    cardData.matched = true;
    game.temp.push({ icon: cardData.icon, id: cardData.id, matched: false });
    game.temp.sort((a, b) => a.icon.localeCompare(b.icon) || a.id - b.id);

    renderTemp();
    renderBoard();
    renderProgress();

    let iconCnt = {};
    game.temp.forEach(c => {
      if (!c.matched) iconCnt[c.icon] = (iconCnt[c.icon] || 0) + 1;
    });

    let matchedIcon = Object.keys(iconCnt).find(k => iconCnt[k] === 3);

    if (matchedIcon) {
      game.temp.forEach(c => { if (c.icon === matchedIcon) c.matched = true; });
      setTimeout(() => {
        game.temp = game.temp.filter(c => !c.matched);
        renderTemp();
        renderBoard();
        checkWin();
        game.lock = false;
      }, 100);
    } else {
      checkWin();
      game.lock = false;
    }
  }, tempAppearanceDelay);
}

function checkWin(){
  if(game.board.every(c=>c.matched)){
    setTimeout(()=>{
      if(game.level===1){
        showLevelFinish('æ­å–œæ­å–œï¼ç¬¬ä¸€å…³é€šå…³ï¼');
      }else{
        showLevelFinish('æ‰€æœ‰å…³å¡å…¨éƒ¨é€šå…³ï¼<br> ğŸ‰ ä½ å¤ªæ£’å•¦ï¼ğŸ‰');
      }
    },330);
  }
}

function saveStep(){
  game.stepStack.push({
    board: deepClone(game.board),
    temp: deepClone(game.temp)
  });
  if(game.stepStack.length>20) game.stepStack.shift();
}
function undoStep(){
  if(game.stepStack.length>0){
    let prev = game.stepStack.pop();
    game.board = deepClone(prev.board);
    game.temp = deepClone(prev.temp);
    renderAll();
    showMessage('å·²æ’¤é”€');
  } else {
    showMessage('æ— æ³•æ’¤é”€æ›´å¤š', '#888');
  }
}
function shuffleStep(){
  let unmatched = game.board.filter(c=>!c.matched);
  let icons = unmatched.map(c=>c.icon);
  shuffle(icons);

  unmatched.forEach((c,i)=>{
      c.icon = icons[i];
  });
  renderAll();
  showMessage('å·²æ´—ç‰Œ');
}

function hintStep(){
  let tempIcons = game.temp.map(c => c.icon);
  let clickableBoardCards = game.board.filter(c => !c.matched && isCardClickable(c, game.board));
  let clickableBoardIcons = clickableBoardCards.map(c => c.icon);

  let allAvailableIcons = [...tempIcons, ...clickableBoardIcons];

  let iconCounts = {};
  allAvailableIcons.forEach(icon => {
    iconCounts[icon] = (iconCounts[icon] || 0) + 1;
  });

  let targetIcon = null;
  for (let icon in iconCounts) {
    if (iconCounts[icon] >= 3) {
      targetIcon = icon;
      break;
    }
  }
  // Remove any existing hint animations/styles before applying new ones
  document.querySelectorAll('.card.hinted-shake').forEach(el => {
      el.classList.remove('hinted-shake');
      el.style.borderColor = ''; // Reset if previously set by hint
      el.style.boxShadow = '';  // Reset if previously set by hint
  });
  document.querySelectorAll('#temp-area .temp-card.hinted-shake').forEach(el => {
      el.classList.remove('hinted-shake');
      el.style.borderColor = ''; // Reset if previously set by hint
      el.style.boxShadow = '';  // Reset if previously set by hint
  });

  if (targetIcon) {
    let hintDone = 0;
    const tempSlots = document.querySelectorAll('#temp-area .temp-slot');
    const hintedElements = []; // To keep track of elements that need animation

    for (let i = 0; i < game.temp.length && hintDone < 3; i++) {
      if (game.temp[i].icon === targetIcon && !game.temp[i].matched) {
        const tempCardElement = tempSlots[i].querySelector('.temp-card');
        if (tempCardElement) {
          // Add the animation class
          tempCardElement.style.borderColor = '#e65c4f';
          tempCardElement.style.boxShadow = '0 0 16px #ff8c69';          
          tempCardElement.classList.add('hinted-shake');
          hintedElements.push(tempCardElement);
          hintDone++;
        }
      }
    }

    for (let i = 0; i < clickableBoardCards.length && hintDone < 3; i++) {
      let boardCard = clickableBoardCards[i];
      if (boardCard.icon === targetIcon) {
        let doms = document.querySelector(`#card-stack-area .card[data-id='${boardCard.id}']`);
        if (doms) {
          // Add the animation class
          doms.classList.add('hinted-shake');
          doms.style.borderColor = '#e65c4f';
          doms.style.boxShadow = '0 0 16px #ff8c69';
          hintedElements.push(doms);
          hintDone++;
        }
      }
    }

    showMessage('å·²æç¤ºå¯æ¶ˆé™¤ä¸‰å¼ ');

    // Remove the animation class after a short duration
    setTimeout(() => {
        hintedElements.forEach(el => {
            el.classList.remove('hinted-shake');
            // Optionally reset border/shadow here if they were used for visual hint too
        });
        renderAll(); // Re-render to ensure styles are clean
    }, 1200); // Animation duration + a little extra
  } else {
    showMessage('å½“å‰æ— å¯ä¸‰æ¶ˆ', "#888");
  }
}

function gameOver(msg){
  game.lock=true;
  document.getElementById('card-stack-area').innerHTML = '';
  document.querySelectorAll('#temp-area .temp-slot').forEach(slot => slot.innerHTML = '');
  document.getElementById('progress-info').textContent = '';
  document.getElementById('message-bar').textContent = '';

  setTimeout(()=>{
    document.getElementById('game-over').style.display='flex';
    document.getElementById('game-over-text').innerHTML=msg;
  },100);
}

function startGame(level){
  footer.style.display = 'block';

  game.level=level;
  if (level === 2) {
    document.body.classList.add('level-2-active');
  } else {
    document.body.classList.remove('level-2-active');
  }

  let lv = genLevel(level);
  game.cards = lv.cards;
  game.board = lv.board;
  game.usedIcons = lv.usedIcons;
  game.temp = [];
  game.matched = [];
  game.toolUses = {undo: 0, hint: 0, shuffle: 0};
  game.stepStack = [];
  game.lock = false;
  game.isNewLevel = true; // Set the flag here
  renderAll();
  updateToolButtons();
  playBgm(game.bgmOn);
}

function renderBoard(){
  const area = document.getElementById('card-stack-area');
  area.innerHTML = '';
  let cardsToRender = game.board.filter(c => !c.matched);

  cardsToRender.sort((a, b) => a.z - b.z);

  const isInitialRenderForLevel = game.isNewLevel; // Capture the state

  cardsToRender.forEach((card, index) => { // Add index to the loop
    let el = document.createElement('div');
    const clickable = isCardClickable(card, game.board);
    el.className = "card" + (clickable ? "" : " disabled");
    el.style.left = card.x+'px';
    el.style.top = card.y+'px';
    el.style.zIndex = card.z;
    el.innerHTML = card.icon;
    el.dataset.id = card.id;

    if(clickable){
      el.onclick = ()=>clickCard(card.id);
    }
     if (isInitialRenderForLevel) {
        el.classList.add('card-entering');
        el.style.animationDelay = `${index * 0.03}s`; // Stagger animation
        el.addEventListener('animationend', function handler() {
            el.classList.remove('card-entering');
            el.style.animationDelay = ''; // Clean up
            el.removeEventListener('animationend', handler);
        }, { once: true });
    }

    area.appendChild(el);
  });
  game.isNewLevel = false; // Reset the flag after rendering
}
function renderTemp(){
  const tempSlots = document.querySelectorAll('#temp-area .temp-slot');
  tempSlots.forEach((slot, i) => {
    slot.innerHTML = '';
    if (i < game.temp.length) {
      const c = game.temp[i];
      let el = document.createElement('div');
      el.className = "temp-card" + (c.matched ? " matched" : "");
      el.innerHTML = c.icon;
      slot.appendChild(el);
    }
  });
}
function renderProgress(){
  const info = document.getElementById('progress-info');
  let left = game.board.filter(c=>!c.matched).length;
  info.textContent = `å…³å¡: ${game.level} / 2 | å‰©ä½™å¡ç‰Œ: ${left}`;
}
function showMessage(msg, color){
  let bar = document.getElementById('message-bar');
  bar.style.color = color||'#c0392b';
  bar.textContent = msg||'';
  if(msg) setTimeout(()=>{bar.textContent='';}, 2300);
}
function updateToolButtons() {
  document.getElementById('undo-count').textContent = game.toolUses.undo;
  document.getElementById('hint-count').textContent = game.toolUses.hint;
  document.getElementById('shuffle-count').textContent = game.toolUses.shuffle;
  document.getElementById('undo-btn').disabled = game.toolUses.undo <= 0;
  document.getElementById('hint-btn').disabled = game.toolUses.hint <= 0;
  document.getElementById('shuffle-btn').disabled = game.toolUses.shuffle <= 0;
}
function renderAll(){
  renderBoard();
  renderTemp();
  renderProgress();
  updateToolButtons();
}

document.getElementById('undo-btn').onclick = function(){
  if(game.toolUses.undo > 0 && game.stepStack.length > 0){
    undoStep();
    game.toolUses.undo--;
    updateToolButtons();
  } else if (game.toolUses.undo > 0 && game.stepStack.length === 0) {
    showMessage('æ— æ³•æ’¤é”€æ›´å¤š', '#888');
  }
};
document.getElementById('hint-btn').onclick = function(){
  if(game.toolUses.hint > 0){
    hintStep();
    game.toolUses.hint--;
    updateToolButtons();
  }
};
document.getElementById('shuffle-btn').onclick = function(){
  if(game.toolUses.shuffle > 0){
    shuffleStep();
    game.toolUses.shuffle--;
    updateToolButtons();
  }
};

document.getElementById('restart-btn').onclick = function() {
    showConfirm('ç¡®å®šè¦é‡æ–°å¼€å§‹å½“å‰å…³å¡å—ï¼Ÿæ‰€æœ‰é“å…·ä½¿ç”¨æ¬¡æ•°å°†é‡ç½®ã€‚', () => {
        startGame(game.level);
        setTimeout(() => {
            showMessage('å…³å¡å·²é‡æ–°å¼€å§‹ï¼', '#3e5a2b');
        }, 50);
    });
};

/*
* MODIFICATION START: Updated the code redemption logic.
* This function now checks the input against the REDEMPTION_CODES object.
*/
document.getElementById('code-btn').onclick=function(){
  let val = document.getElementById('code-input').value.trim().toLowerCase();

  if (REDEMPTION_CODES[val]) {
    const rewards = REDEMPTION_CODES[val];

    // New logic for "skip_level" code
    if (rewards.type === "skip_level") {
      // Simulate winning the current level
      game.board.forEach(card => card.matched = true); // Mark all cards as matched
      renderBoard(); // Update the board display
      renderProgress(); // Update the progress display
      checkWin(); // Check for win condition
      showMessage(`å…‘æ¢æˆåŠŸï¼å½“å‰å…³å¡å·²è·³è¿‡ï¼`, "#3e5a2b"); // Success message
    } else {
      // Existing logic for tool redemption
      game.toolUses.undo += rewards.undo;
      game.toolUses.hint += rewards.hint;
      game.toolUses.shuffle += rewards.shuffle;

      // Optional: Add a check to prevent reusing codes
      // delete REDEMPTION_CODES[val];

      showMessage(`å…‘æ¢æˆåŠŸï¼è·å¾—æ’¤é”€x${rewards.undo}, æç¤ºx${rewards.hint}, æ´—ç‰Œx${rewards.shuffle}`, "#3e5a2b");
    }
    updateToolButtons();
  } else {
    showMessage('å…‘æ¢ç é”™è¯¯', "#c0392b");
  }
  document.getElementById('code-input').value='';
};
// MODIFICATION END

document.getElementById('music-toggle').onclick=function(){
  game.bgmOn = !game.bgmOn;
  this.innerHTML = game.bgmOn?'ğŸ¼':'ğŸ”‡';
  playBgm(game.bgmOn);
};
document.getElementById('start-btn').onclick = function(){
  document.getElementById('start-screen').style.display='none';
  startGame(1);
};
document.getElementById('next-btn').onclick = function(){
  document.getElementById('level-finish').style.display='none';
  startGame(2);
};
document.getElementById('retry-btn').onclick = function(){
  document.getElementById('level-finish').style.display='none';
  startGame(game.level);
};
document.getElementById('retry-btn2').onclick = function(){
  document.getElementById('game-over').style.display='none';
  startGame(game.level);
};
function showLevelFinish(msg){
  document.getElementById('level-finish').style.display='flex';
  const levelFinishTextElement = document.getElementById('level-finish-text'); // è·å–å…ƒç´ å¼•ç”¨
  levelFinishTextElement.innerHTML=msg; // ä½¿ç”¨å¼•ç”¨

  // æ ¹æ®å…³å¡è®¾ç½®ä¸åŒçš„åŠ¨ç”»æ•ˆæœ
  if (game.level === 1) {
    levelFinishTextElement.style.animation = 'shake 3s infinite, show-card-property 8s forwards';
    levelFinishTextElement.innerHTML += '<br>ç¬¬äºŒå…³åä¼šæœ‰å½©è›‹ğŸª…ï¼'; // ä¿æŒç¬¬ä¸€å…³çš„å½©è›‹æç¤º
  } else if (game.level === 2) {
    levelFinishTextElement.style.animation = 'pulse-scale 2s infinite alternate, wave 2s infinite'; // ç¬¬äºŒå…³ä½¿ç”¨æ–°çš„åŠ¨ç”»
  } else {
    // é»˜è®¤æƒ…å†µæˆ–ä¸ºå…¶ä»–å…³å¡è®¾ç½®æ— åŠ¨ç”»æˆ–ç‰¹å®šåŠ¨ç”»
    levelFinishTextElement.style.animation = ''; // æ¸…é™¤åŠ¨ç”»
  }

  document.getElementById('next-btn').style.display = (game.level===1)?'inline-block':'none';

  // æ§åˆ¶éŸ³ä¹æ’­æ”¾å™¨å’Œäº”å­æ£‹æŒ‰é’®çš„å¯è§æ€§ï¼ˆä¿ç•™åŸæœ‰é€»è¾‘ï¼‰
  const playerDiv = document.getElementById('player');
  const gobangBtn = document.getElementById('gobang-btn');

  if (game.level === 2) {
    playerDiv.style.display = 'block';
    if (gobangBtn) {
      gobangBtn.style.display = 'inline-block';
    }
  } else {
    playerDiv.style.display = 'none';
    if (gobangBtn) {
      gobangBtn.style.display = 'none';
    }
  }

  playBgm(false);
}

document.getElementById('next-btn').onclick = function(){
      document.getElementById('level-finish').style.display='none';
      startGame(2);
      playBgm(game.bgmOn);
    };

    document.getElementById('retry-btn').onclick = function(){
      document.getElementById('level-finish').style.display='none';
      startGame(1);
      playBgm(game.bgmOn);
    };
    document.getElementById('gobang-btn').onclick = function() {
      window.open('https://kaiyuanzhuadmin.github.io/kaiyuan/', '_blank');
    };
// Modified this function to be callable later
function initializeGame(){
  document.getElementById('music-toggle').innerHTML = game.bgmOn?'ğŸ¼':'ğŸ”‡';
  updateToolButtons();
  footer.style.display = 'none';
// è®¾ç½®èƒŒæ™¯éŸ³ä¹çš„éŸ³é‡
    if (bgm) {
        bgm.volume = 0.3; // å°†éŸ³é‡è®¾ç½®ä¸º 0.5 (50%)ã€‚ä½ å¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´è¿™ä¸ªå€¼ã€‚
                          // 0.0 æ˜¯é™éŸ³ï¼Œ1.0 æ˜¯æœ€å¤§éŸ³é‡ã€‚
    }

    // æ’­æ”¾èƒŒæ™¯éŸ³ä¹
    if (bgm && game.bgmOn) { // ç¡®ä¿ bgmOn æ˜¯ä¸€ä¸ªæ§åˆ¶èƒŒæ™¯éŸ³ä¹æ’­æ”¾çš„å˜é‡
        bgm.play().catch(e => console.error("BGM playback failed:", e));
    }
}
// For Level Finish screen
document.getElementById('close-game-btn-level').onclick = function() {
    showConfirm('ç¡®å®šè¦å…³é—­æ¸¸æˆå—ï¼Ÿ', () => {
        // Attempt to close the window. This will likely only work if the window
        // was opened by a script (e.g., via window.open() from your domain).
        // Otherwise, browsers will often prevent it for security reasons.
        window.close();

        // Fallback or message if window.close() fails
        setTimeout(() => {
            document.getElementById('game-container').style.display = 'none';
            document.body.innerHTML = '<div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100vh; font-size:2em; color:#5d4037; text-align:center;opacity: 1;">æ„Ÿè°¢æ¸¸ç©ï¼æ— æ³•è‡ªåŠ¨å…³é—­é¡µé¢ï¼Œè¯·æ‰‹åŠ¨å…³é—­ã€‚<br><br><small style="font-size:0.5em;">å–µäº†ä¸ªå’ª &copy; 2025 | Designed by å¼€å…ƒ</small></div>';
        }, 100); // Give a small delay to allow window.close() to attempt
    });
};

// For Game Over screen
document.getElementById('close-game-btn-gameover').onclick = function() {
    showConfirm('ç¡®å®šè¦å…³é—­æ¸¸æˆå—ï¼Ÿ', () => {
        // Attempt to close the window. Same caveats as above apply.
        window.close();

        // Fallback or message if window.close() fails
        setTimeout(() => {
            document.getElementById('game-container').style.display = 'none';
            document.body.innerHTML = '<div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100vh; font-size:2em; color:#5d4037; text-align:center;">æ„Ÿè°¢æ¸¸ç©ï¼æ— æ³•è‡ªåŠ¨å…³é—­é¡µé¢ï¼Œè¯·æ‰‹åŠ¨å…³é—­ã€‚<br><br><small style="font-size:0.5em;">å–µäº†ä¸ªå’ª &copy; 2025 | Designed by å¼€å…ƒ</small></div>';
        }, 100); // Give a small delay to allow window.close() to attempt
    });
};
</script>

<script>
// ä¿®æ”¹ç‚¹2ï¼šåœ¨DOMåŠ è½½å®Œæˆäº‹ä»¶ä¸­æ·»åŠ æ ‡é¢˜ä¿®æ”¹é€»è¾‘
document.addEventListener('DOMContentLoaded', () => {
    const loadingScreen = document.getElementById('loading-screen');
    const progressBar = document.getElementById('progress-bar');
    const loadingText = document.getElementById('loading-text');

    let progress = 0;
    const assets = ["åŠ è½½å­—ä½“...", "åŠ è½½éŸ³æ•ˆ...", "åŠ è½½å›¾ç‰‡...", "åˆå§‹åŒ–å…³å¡...", "å‡†å¤‡å–µå’ª...", "å®Œæˆ!"];
    let assetIndex = 0;
    loadingText.textContent = assets[0];

    const interval = setInterval(() => {
        progress += Math.random() * 15 + 5;
        
        if (progress >= 100) {
            progress = 100;
            clearInterval(interval);
            
            progressBar.style.width = progress + '%';
            loadingText.textContent = assets[assets.length - 1];

            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                loadingScreen.addEventListener('transitionend', () => {
                    loadingScreen.style.display = 'none';
                    document.title = "å–µäº†ä¸ªå’ª";
                    initializeGame();
                }, { once: true });
            }, 400);
        } else {
            progressBar.style.width = progress + '%';
            const nextAssetThreshold = (assetIndex + 1) * 20;
            if (progress > nextAssetThreshold && assetIndex < assets.length - 2) {
                assetIndex++;
                loadingText.textContent = assets[assetIndex];
            }
        }
    }, 250);
});
</script>
</body>
</html>
